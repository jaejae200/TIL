# 그래프 (Graph) ✒

-  #### 정점(Vertex) 과 이를 연결하는 간선(Edge) 들의 집합으로 이루어진 비선형 자료구조

  

## 📝 그래프에 대한 이해

-  #### 소셜 네트워크와 지하철 노선도와 같이, 현실에 있는 개체 간의 관계를 나타내기 위해 사용

### 📌 그래프 관련 용어

- 정점 (Vertex) : 간선으로 연결되는 객체, 노드 (Node) 라고도 한다

- 간선 (Edge) : 정점 간의 관계(연결)를 표현하는 선

- 경로 (Path) : 시작 정점부터 도착 정점까지 거치는 정점을 나열한 것

- 인접 (Adjacency) : 두 개의 정점이 하나의 간선으로 직접 연결된 상태



## 📝 그래프의 종류

### 📌 무방향 그래프 (Undirected graph)

- **간선의 방향이 없는** 가장 일반적인 그래프
- 간선을 통해 양방향의 정점 이동 가능
- **차수 (Degree)** : 하나의 정점에 연결된 간선의 개수
- 모든 정점의 차수의 합 = **간선 수 * 2**



### 📌 유방향 그래프 (Directed graph)

- **간선의 방향이 있는** 그래프
- 간선의 방향이 가르키는 정점으로 이동 가능
- **차수 (Degree)** : 진입 차수와 진출 차수로 이루어짐
  - 진입 차수 (in-degree) : 외부 정점에서 한 정점으로 들어오는 간선의 수
  - 진출 차수 (out-degree) : 한 정점에서 외부 정점으로 나가는 간선의 수



## ⭐ 그래프의 표현  

그래프를 실제 문서에서 어떻게 코드로 표현할까 ?



### 📌 인접 리스트 (Adjacency list)

**리스트를 통해 각 정점에 대한 인접 정점들을 순차적으로 표현하는 방식**

```python
# key = node (정점) value = 인접
# =================================
graph = {
    0 : [1, 2]
    1 : [0, 3, 4],
    2 : [0, 4, 5],
    3 : [1],
    4 : [1, 2, 6],
    5 : [2],
    6 : [4]
}

# graph[0][0] >>> 1
# =================================
graph = [
    [1, 2],
    [0, 3, 4],
    [0, 4, 5],
    [1],
    [1, 2, 6],
    [2],
    [4]
]

# graph[0][0] >>> 1 
# =================================

# 문자도 가능하다
subway = {
    'yeoksam' : ['gangnam', 'Seolleung']
    'Seolleung' : ['yeoksam', 'samsung', 'Seonjeongneung', 'hanti']
}

# ===================================================

# 인접 리스트 만들기

n = 7 # 정점 개수
m = 7 # 간선 개수

graph = [[] * n for _ in range(n)] # n by n

'''
인접 리스트 결과

graph = [
	[1, 2],
	[0, 3, 4],
	[0, 4, 5],
	[1],
	[1, 2, 6],
	[2],
	[4],		
]
'''

for _ in range(m):  
    v1, v2 = map(int, input().split())
    graph[v1].append(v2)
    graph[v2].append(v1)
```



### 📌 인접 행렬 (Adjacency matrix)

**두 정점을 연결하는 간선이 없으면 0 있으면 1을 가지는 행렬로 표현하는 방식**

```python
edges = [
    [0, 1],
    [0, 2],
    [1, 3],
    [1, 4],
    [2, 4],
    [2, 5],
    [4, 6]
]

graph = [[0] * n for _ in range(n)] # n by n

'''
 graph = [
	[0, 1, 1, 0, 0, 0, 0]
    [1, 0, 0, 1, 1, 0, 0]                           
    [1, 0, 0, 0, 1, 1, 0]
    [0, 1, 0, 0, 0, 0, 0]
    [0, 1, 1, 0, 0, 0, 1]                     
    [0, 0, 1, 0, 0, 0, 0]
    [0, 0, 0, 0, 1, 0, 0]              
'''

for edge in graph:
    v1, v2 = edge[0], edge[1]
    graph[v1][v2] = 1
    graph[v2][v1] = 1

# 값을 다 받아서 set 하면 정점 값을 구할 수 있음 set(*edges)
# => flatten
# flatten_edges = [0, 1, 0, 2, 1, 3, 1, 4, 2, 4, 2, 5, 4, 6]
# print(*edges)

# ============================================================

# 인접 행렬 만들기

n = 7 # 정점 개수
m = 7 # 간선 개수

graph = [[0] * n for _ in range(n)] # n by n

for _ in range(m):  
    v1, v2 = map(int, input().split())
    graph[v1][v2] = 1
    graph[v1][v2] = 1
```

### 📌 인접 행렬 vs 인접 리스트

- **장점**
  - 인접 행렬 : 직관적이고 만들기 편하다
  - 인접 리스트 : 연결된 정점만 저장하여 효율적이다.
- **단점**
  - 인접 행렬 : 불필요하게 공간이 낭비된다.

```python
# 인접 행렬 정리

'''
graph = [
	[0, 1, 1, 0, 0, 0, 0]
    [1, 0, 0, 1, 1, 0, 0]
    [1, 0, 0, 0, 1, 1, 0]
    [0, 1, 0, 0, 0, 0, 0]
    [0, 1, 1, 0, 0, 0, 1]
    [0, 0, 1, 0, 0, 0, 0]
    [0, 0, 0, 0, 1, 0, 0]
'''

# 인접 리스트 정리

'''
graph = [
	[1, 2],
	[0, 3, 4],
	[0, 4, 5],
	[1],
	[1, 2, 6],
	[2],
	[4],		
]
'''


```

- ### 인접 리스트와 인접 행렬 모두 효율적인 방법이 존재한다! 



